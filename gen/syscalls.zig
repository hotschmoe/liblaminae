// Auto-generated by `zig build gen-lib` - do not edit.
// Source: src/kernel/syscalls/table.zig

const errors = @import("errors.zig");

pub const Syscall = enum(u64) {
    exit = 100,
    yield = 101,
    write = 102,
    get_time = 103,
    spawn = 104,
    kill = 105,
    get_container_id = 106,
    sleep = 107,
    wait_for_exit = 108,
    read = 109,
    get_platform = 110,
    wait_event = 111,
    console_ctl = 112,
    get_crash_telemetry = 113,
    container_list = 114,
    container_log_read = 115,
    icc_send = 120,
    icc_recv = 121,
    ns_register = 130,
    ns_lookup = 131,
    ns_wait = 132,
    map_create = 140,
    map_attach = 141,
    map_detach = 142,
    brk = 143,
    cache_clean_range = 150,
    cache_invalidate_range = 151,
    cache_clean_invalidate_range = 152,
    map_device = 160,
    irq_register = 161,
    irq_ack = 162,
    alloc_dma = 163,
    get_device_list = 164,
    get_assigned_device = 165,
    device_graph_count = 166,
    device_graph_get_node = 167,
    device_graph_get_reg = 168,
    device_graph_get_irq = 169,
    device_graph_get_dep = 170,
    get_my_dependencies = 171,
    fs_open = 220,
    fs_close = 221,
    fs_seek = 222,
    fs_stat = 223,
    fs_unlink = 224,
    fs_readdir = 225,
};

pub const Message = extern struct { source_id: u16, msg_type: u16, flags: u32, payload: [248]u8 };
pub const DeviceInfo = extern struct { id: u32, mmio_base: u64, mmio_size: u64, irq: u32, irq2: u32, compatible: [64]u8 };
pub const RegEntry = extern struct { phys_addr: u64, size: u64 };
pub const DeviceGraphNode = extern struct {
    id: u32,
    phandle: u32,
    reg_count: u8,
    irq_count: u8,
    clock_dep_count: u8,
    reset_dep_count: u8,
    power_dep_count: u8,
    phy_dep_count: u8,
    _padding: [2]u8,
    compatible: [64]u8,

    pub fn getCompatible(self: *const DeviceGraphNode) []const u8 {
        const std = @import("std");
        const len = std.mem.indexOfScalar(u8, &self.compatible, 0) orelse 64;
        return self.compatible[0..len];
    }
};
pub const DepKind = enum(u8) { clock = 0, reset = 1, power = 2, phy = 3 };
pub const DeviceDependencies = extern struct {
    clocks: [4]u32,
    clock_count: u8,
    resets: [4]u32,
    reset_count: u8,
    power_domains: [4]u32,
    power_count: u8,
    phys: [4]u32,
    phy_count: u8,
    _padding: [4]u8,
};
pub const ContainerInfo = extern struct {
    id: u16,
    container_type: u8,
    state: u8,
    name_len: u8,
    _pad: [3]u8,
    name: [32]u8,
    start_time_ns: u64,

    pub fn getName(self: *const ContainerInfo) []const u8 {
        return self.name[0..self.name_len];
    }
};
pub const DirEntry = extern struct {
    name: [64]u8,
    name_len: u8,
    file_type: u8,
    _padding: [6]u8,
    size: u64,
};
pub const Stat = extern struct {
    dev: u64,
    ino: u64,
    mode: u32,
    nlink: u32,
    uid: u32,
    gid: u32,
    rdev: u64,
    size: i64,
    blksize: i64,
    blocks: i64,
    atime_sec: i64,
    atime_nsec: i64,
    mtime_sec: i64,
    mtime_nsec: i64,
    ctime_sec: i64,
    ctime_nsec: i64,
    __reserved: [3]i64 = .{ 0, 0, 0 },
};
pub const WakeReason = enum(u64) {
    irq = 1,
    icc = 2,
    timeout = 3,
    peer_crashed = 4,
    @"error" = 0xFFFFFFFF,

    pub fn fromU64(val: u64) WakeReason {
        return @enumFromInt(val);
    }
};

inline fn svc0(num: u64) u64 { return asm volatile ("svc #0" : [ret] "={x0}" (-> u64), : [num] "{x8}" (num) : .{ .memory = true }); }
inline fn svc1(num: u64, a0: u64) u64 { return asm volatile ("svc #0" : [ret] "={x0}" (-> u64), : [num] "{x8}" (num), [a0] "{x0}" (a0) : .{ .memory = true }); }
inline fn svc2(num: u64, a0: u64, a1: u64) u64 { return asm volatile ("svc #0" : [ret] "={x0}" (-> u64), : [num] "{x8}" (num), [a0] "{x0}" (a0), [a1] "{x1}" (a1) : .{ .memory = true }); }
inline fn svc3(num: u64, a0: u64, a1: u64, a2: u64) u64 { return asm volatile ("svc #0" : [ret] "={x0}" (-> u64), : [num] "{x8}" (num), [a0] "{x0}" (a0), [a1] "{x1}" (a1), [a2] "{x2}" (a2) : .{ .memory = true }); }
inline fn svc4(num: u64, a0: u64, a1: u64, a2: u64, a3: u64) u64 { return asm volatile ("svc #0" : [ret] "={x0}" (-> u64), : [num] "{x8}" (num), [a0] "{x0}" (a0), [a1] "{x1}" (a1), [a2] "{x2}" (a2), [a3] "{x3}" (a3) : .{ .memory = true }); }

pub inline fn exit(status: u64) noreturn {
    _ = svc1(@intFromEnum(Syscall.exit), status);
    unreachable;
}

pub inline fn yield() u64 {
    return svc0(@intFromEnum(Syscall.yield));
}

pub inline fn write(fd: u64, buf: *const u8, len: u64) u64 {
    return svc3(@intFromEnum(Syscall.write), fd, @intFromPtr(buf), len);
}

pub inline fn get_time() u64 {
    return svc0(@intFromEnum(Syscall.get_time));
}

pub inline fn spawn(name_ptr: *const u8, name_len: u64, container_type: u8, device_info_ptr: ?*const DeviceInfo) u64 {
    return svc4(@intFromEnum(Syscall.spawn), @intFromPtr(name_ptr), name_len, container_type, @intFromPtr(device_info_ptr));
}

pub inline fn kill(container_id: u16) u64 {
    return svc1(@intFromEnum(Syscall.kill), container_id);
}

pub inline fn get_container_id() u64 {
    return svc0(@intFromEnum(Syscall.get_container_id));
}

pub inline fn sleep(nanoseconds: u64) u64 {
    return svc1(@intFromEnum(Syscall.sleep), nanoseconds);
}

pub inline fn wait_for_exit(container_id: u16) u64 {
    return svc1(@intFromEnum(Syscall.wait_for_exit), container_id);
}

pub inline fn read(fd: u64, buf: *u8, len: u64, flags: u64) u64 {
    return svc4(@intFromEnum(Syscall.read), fd, @intFromPtr(buf), len, flags);
}

pub inline fn get_platform() u64 {
    return svc0(@intFromEnum(Syscall.get_platform));
}

pub inline fn wait_event(irq_mask: u32, mailbox_id: u16, flags: u16, timeout_ns: u64) u64 {
    return svc4(@intFromEnum(Syscall.wait_event), irq_mask, mailbox_id, flags, timeout_ns);
}

pub inline fn console_ctl(op: u64, arg0: u64, arg1: u64) u64 {
    return svc3(@intFromEnum(Syscall.console_ctl), op, arg0, arg1);
}

pub inline fn get_crash_telemetry(buffer_ptr: u64, json_buf_ptr: u64, json_buf_len: u64) u64 {
    return svc3(@intFromEnum(Syscall.get_crash_telemetry), buffer_ptr, json_buf_ptr, json_buf_len);
}

pub inline fn container_list(buffer_ptr: *ContainerInfo, max_entries: u64) u64 {
    return svc2(@intFromEnum(Syscall.container_list), @intFromPtr(buffer_ptr), max_entries);
}

pub inline fn container_log_read(container_id: u16, buffer_ptr: *u8, buffer_len: u64) u64 {
    return svc3(@intFromEnum(Syscall.container_log_read), container_id, @intFromPtr(buffer_ptr), buffer_len);
}

pub inline fn icc_send(target_id: u16, msg_ptr: *const Message) u64 {
    return svc2(@intFromEnum(Syscall.icc_send), target_id, @intFromPtr(msg_ptr));
}

pub inline fn icc_recv(msg_ptr: *Message, timeout_ns: u64) u64 {
    return svc2(@intFromEnum(Syscall.icc_recv), @intFromPtr(msg_ptr), timeout_ns);
}

pub inline fn ns_register(name_ptr: *const u8, name_len: u64) u64 {
    return svc2(@intFromEnum(Syscall.ns_register), @intFromPtr(name_ptr), name_len);
}

pub inline fn ns_lookup(name_ptr: *const u8, name_len: u64) u64 {
    return svc2(@intFromEnum(Syscall.ns_lookup), @intFromPtr(name_ptr), name_len);
}

pub inline fn ns_wait(name_ptr: *const u8, name_len: u64, timeout_ns: u64) u64 {
    return svc3(@intFromEnum(Syscall.ns_wait), @intFromPtr(name_ptr), name_len, timeout_ns);
}

pub inline fn map_create(size_pages: u64, flags: u64) u64 {
    return svc2(@intFromEnum(Syscall.map_create), size_pages, flags);
}

pub inline fn map_attach(handle: u64, perms: u64) u64 {
    return svc2(@intFromEnum(Syscall.map_attach), handle, perms);
}

pub inline fn map_detach(handle: u64) u64 {
    return svc1(@intFromEnum(Syscall.map_detach), handle);
}

pub inline fn brk(new_break: u64) u64 {
    return svc1(@intFromEnum(Syscall.brk), new_break);
}

pub inline fn cache_clean_range(addr: u64, size: u64) u64 {
    return svc2(@intFromEnum(Syscall.cache_clean_range), addr, size);
}

pub inline fn cache_invalidate_range(addr: u64, size: u64) u64 {
    return svc2(@intFromEnum(Syscall.cache_invalidate_range), addr, size);
}

pub inline fn cache_clean_invalidate_range(addr: u64, size: u64) u64 {
    return svc2(@intFromEnum(Syscall.cache_clean_invalidate_range), addr, size);
}

pub inline fn map_device(phys_addr: u64, size: u64) u64 {
    return svc2(@intFromEnum(Syscall.map_device), phys_addr, size);
}

pub inline fn irq_register(irq_num: u64) u64 {
    return svc1(@intFromEnum(Syscall.irq_register), irq_num);
}

pub inline fn irq_ack(irq_num: u64) u64 {
    return svc1(@intFromEnum(Syscall.irq_ack), irq_num);
}

pub inline fn alloc_dma(size: u64) u64 {
    return svc1(@intFromEnum(Syscall.alloc_dma), size);
}

pub inline fn get_device_list(buffer_ptr: *DeviceInfo, max_count: u64) u64 {
    return svc2(@intFromEnum(Syscall.get_device_list), @intFromPtr(buffer_ptr), max_count);
}

pub inline fn get_assigned_device(buffer_ptr: *DeviceInfo) u64 {
    return svc1(@intFromEnum(Syscall.get_assigned_device), @intFromPtr(buffer_ptr));
}

pub inline fn device_graph_count() u64 {
    return svc0(@intFromEnum(Syscall.device_graph_count));
}

pub inline fn device_graph_get_node(device_id: u32, buffer_ptr: *DeviceGraphNode) u64 {
    return svc2(@intFromEnum(Syscall.device_graph_get_node), device_id, @intFromPtr(buffer_ptr));
}

pub inline fn device_graph_get_reg(device_id: u32, reg_index: u32, buffer_ptr: *RegEntry) u64 {
    return svc3(@intFromEnum(Syscall.device_graph_get_reg), device_id, reg_index, @intFromPtr(buffer_ptr));
}

pub inline fn device_graph_get_irq(device_id: u32, irq_index: u32, buffer_ptr: *u32) u64 {
    return svc3(@intFromEnum(Syscall.device_graph_get_irq), device_id, irq_index, @intFromPtr(buffer_ptr));
}

pub inline fn device_graph_get_dep(device_id: u32, dep_kind: u8, dep_index: u32, buffer_ptr: *u32) u64 {
    return svc4(@intFromEnum(Syscall.device_graph_get_dep), device_id, dep_kind, dep_index, @intFromPtr(buffer_ptr));
}

pub inline fn get_my_dependencies(buffer_ptr: *DeviceDependencies) u64 {
    return svc1(@intFromEnum(Syscall.get_my_dependencies), @intFromPtr(buffer_ptr));
}

pub inline fn fs_open(name_ptr: *const u8, name_len: u64, flags: u32) u64 {
    return svc3(@intFromEnum(Syscall.fs_open), @intFromPtr(name_ptr), name_len, flags);
}

pub inline fn fs_close(fd: u64) u64 {
    return svc1(@intFromEnum(Syscall.fs_close), fd);
}

pub inline fn fs_seek(fd: u64, offset: i64, origin: u8) u64 {
    return svc3(@intFromEnum(Syscall.fs_seek), fd, offset, origin);
}

pub inline fn fs_stat(fd: u64, stat_buf: *Stat) u64 {
    return svc2(@intFromEnum(Syscall.fs_stat), fd, @intFromPtr(stat_buf));
}

pub inline fn fs_unlink(name_ptr: *const u8, name_len: u64) u64 {
    return svc2(@intFromEnum(Syscall.fs_unlink), @intFromPtr(name_ptr), name_len);
}

pub inline fn fs_readdir(path_ptr: *const u8, path_len: u64, buf_ptr: *DirEntry, max_entries: u64) u64 {
    return svc4(@intFromEnum(Syscall.fs_readdir), @intFromPtr(path_ptr), path_len, @intFromPtr(buf_ptr), max_entries);
}

